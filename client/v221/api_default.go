/*
OCPI modules

Specification for OCPIs modules handlers

API version: 2.2.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package OCPI

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiOcpi221CredentialsDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r ApiOcpi221CredentialsDeleteRequest) Execute() (*Credentials, *http.Response, error) {
	return r.ApiService.Ocpi221CredentialsDeleteExecute(r)
}

/*
Ocpi221CredentialsDelete Informs that credentials are invalid

Informs the server that its credentials to access the client's system are now invalid and can no longer be used. Both parties must end any automated communication. This is the unregistration process. This method MUST return a HTTP status code 405: method not allowed if the client has not been registered before.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpi221CredentialsDeleteRequest
*/
func (a *DefaultApiService) Ocpi221CredentialsDelete(ctx context.Context) ApiOcpi221CredentialsDeleteRequest {
	return ApiOcpi221CredentialsDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Credentials
func (a *DefaultApiService) Ocpi221CredentialsDeleteExecute(r ApiOcpi221CredentialsDeleteRequest) (*Credentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Credentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Ocpi221CredentialsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/2.2.1/credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpi221CredentialsGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r ApiOcpi221CredentialsGetRequest) Execute() (*Credentials, *http.Response, error) {
	return r.ApiService.Ocpi221CredentialsGetExecute(r)
}

/*
Ocpi221CredentialsGet Get the credentials object

Retrieves the credentials object to access the server's platform. The request body is empty, the response contains the credentials object to  access the server's platform. This credentials object also contains extra  information about the server such as its business details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpi221CredentialsGetRequest
*/
func (a *DefaultApiService) Ocpi221CredentialsGet(ctx context.Context) ApiOcpi221CredentialsGetRequest {
	return ApiOcpi221CredentialsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Credentials
func (a *DefaultApiService) Ocpi221CredentialsGetExecute(r ApiOcpi221CredentialsGetRequest) (*Credentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Credentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Ocpi221CredentialsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/2.2.1/credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpi221CredentialsPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	credentials *Credentials
}

func (r ApiOcpi221CredentialsPostRequest) Credentials(credentials Credentials) ApiOcpi221CredentialsPostRequest {
	r.credentials = &credentials
	return r
}

func (r ApiOcpi221CredentialsPostRequest) Execute() (*Credentials, *http.Response, error) {
	return r.ApiService.Ocpi221CredentialsPostExecute(r)
}

/*
Ocpi221CredentialsPost Provides the credentials object

Provides the server with credentials to access the client's system. This credentials object also contains extra information about the client such as its business details. A POST initiates the registration process for this endpoint's version. The server must also fetch the client's endpoints for this version. OCPI 2.2.1 If successful, the server must generate a new credentials token and respond with the client's new credentials to access the server's system. The credentials object in the response also contains extra information about the server such as its business details. This method MUST return a HTTP status code 405: method not allowed if the client has already been registered before.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpi221CredentialsPostRequest
*/
func (a *DefaultApiService) Ocpi221CredentialsPost(ctx context.Context) ApiOcpi221CredentialsPostRequest {
	return ApiOcpi221CredentialsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Credentials
func (a *DefaultApiService) Ocpi221CredentialsPostExecute(r ApiOcpi221CredentialsPostRequest) (*Credentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Credentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Ocpi221CredentialsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/2.2.1/credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.credentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpi221CredentialsPutRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	credentials *Credentials
}

func (r ApiOcpi221CredentialsPutRequest) Credentials(credentials Credentials) ApiOcpi221CredentialsPutRequest {
	r.credentials = &credentials
	return r
}

func (r ApiOcpi221CredentialsPutRequest) Execute() (*Credentials, *http.Response, error) {
	return r.ApiService.Ocpi221CredentialsPutExecute(r)
}

/*
Ocpi221CredentialsPut Provides updated credentials object

Provides the server with updated credentials to access the client's system. This credentials object also contains extra information about the client such as its business details. A PUT will switch to the version that contains this credentials endpoint if it's different from the current version. The server must fetch the client's endpoints again, even if the version has not changed. If successful, the server must generate a new credentials token for the client and respond with the client's updated credentials to access the server's system. The credentials object in the response also contains extra information about the server such as its business details. This method MUST return a HTTP status code 405: method not allowed if the client has not been registered yet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpi221CredentialsPutRequest
*/
func (a *DefaultApiService) Ocpi221CredentialsPut(ctx context.Context) ApiOcpi221CredentialsPutRequest {
	return ApiOcpi221CredentialsPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Credentials
func (a *DefaultApiService) Ocpi221CredentialsPutExecute(r ApiOcpi221CredentialsPutRequest) (*Credentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Credentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Ocpi221CredentialsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/2.2.1/credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.credentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpi221DetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r ApiOcpi221DetailsGetRequest) Execute() (*Details, *http.Response, error) {
	return r.ApiService.Ocpi221DetailsGetExecute(r)
}

/*
Ocpi221DetailsGet Get version supported endpoints

Fetch information about the supported endpoints for version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpi221DetailsGetRequest
*/
func (a *DefaultApiService) Ocpi221DetailsGet(ctx context.Context) ApiOcpi221DetailsGetRequest {
	return ApiOcpi221DetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Details
func (a *DefaultApiService) Ocpi221DetailsGetExecute(r ApiOcpi221DetailsGetRequest) (*Details, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Details
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Ocpi221DetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/2.2.1/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiCdrsGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	dateFrom *string
	dateTo *string
	offset *int32
	limit *int32
}

// Return CDRs that have last_updated after or equal to this Date/Time (inclusive).
func (r ApiOcpiCdrsGetRequest) DateFrom(dateFrom string) ApiOcpiCdrsGetRequest {
	r.dateFrom = &dateFrom
	return r
}

// Return CDRs that have last_updated up to this Date/Time, but not including (exclusive).
func (r ApiOcpiCdrsGetRequest) DateTo(dateTo string) ApiOcpiCdrsGetRequest {
	r.dateTo = &dateTo
	return r
}

// The offset of the first object returned. Default is 0.
func (r ApiOcpiCdrsGetRequest) Offset(offset int32) ApiOcpiCdrsGetRequest {
	r.offset = &offset
	return r
}

// Maximum number of objects to GET.
func (r ApiOcpiCdrsGetRequest) Limit(limit int32) ApiOcpiCdrsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiOcpiCdrsGetRequest) Execute() (*CdrsResponse, *http.Response, error) {
	return r.ApiService.OcpiCdrsGetExecute(r)
}

/*
OcpiCdrsGet Get CDRs

Fetch CDRs from the CPO's system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpiCdrsGetRequest
*/
func (a *DefaultApiService) OcpiCdrsGet(ctx context.Context) ApiOcpiCdrsGetRequest {
	return ApiOcpiCdrsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CdrsResponse
func (a *DefaultApiService) OcpiCdrsGetExecute(r ApiOcpiCdrsGetRequest) (*CdrsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CdrsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiCdrsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/cdrs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiCdrsPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	cdrBody *CdrBody
}

func (r ApiOcpiCdrsPostRequest) CdrBody(cdrBody CdrBody) ApiOcpiCdrsPostRequest {
	r.cdrBody = &cdrBody
	return r
}

func (r ApiOcpiCdrsPostRequest) Execute() (*CdrResponse, *http.Response, error) {
	return r.ApiService.OcpiCdrsPostExecute(r)
}

/*
OcpiCdrsPost Create CDR object

Creates a new CDR. The POST method should contain the full and final CDR object.  Returns URL of created CDR object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpiCdrsPostRequest
*/
func (a *DefaultApiService) OcpiCdrsPost(ctx context.Context) ApiOcpiCdrsPostRequest {
	return ApiOcpiCdrsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CdrResponse
func (a *DefaultApiService) OcpiCdrsPostExecute(r ApiOcpiCdrsPostRequest) (*CdrResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CdrResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiCdrsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/cdrs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cdrBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiChargingprofilePostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	ocpiChargingprofilePostRequest *OcpiChargingprofilePostRequest
}

func (r ApiOcpiChargingprofilePostRequest) OcpiChargingprofilePostRequest(ocpiChargingprofilePostRequest OcpiChargingprofilePostRequest) ApiOcpiChargingprofilePostRequest {
	r.ocpiChargingprofilePostRequest = &ocpiChargingprofilePostRequest
	return r
}

func (r ApiOcpiChargingprofilePostRequest) Execute() (*GenericResponse, *http.Response, error) {
	return r.ApiService.OcpiChargingprofilePostExecute(r)
}

/*
OcpiChargingprofilePost Send a result of the original request by the eMSP

There are no URL segment parameters required by OCPI.  As the Sender interface is called by the Receiver (typically CPO) on  the URL given response_url in the Sender request to the Receiver interface.  It is up to the implementation of the Sender (typically SCSP) to determine  what parameters are put in the URL. The Sender sends a URL in the POST method  body to the Receiver. The Receiver is required to use this URL for the asynchronous  response by the Charge Point. It is advised to make this URL unique for every  request to differentiate simultaneous commands, for example by adding a unique  id as a URL segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpiChargingprofilePostRequest
*/
func (a *DefaultApiService) OcpiChargingprofilePost(ctx context.Context) ApiOcpiChargingprofilePostRequest {
	return ApiOcpiChargingprofilePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenericResponse
func (a *DefaultApiService) OcpiChargingprofilePostExecute(r ApiOcpiChargingprofilePostRequest) (*GenericResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenericResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiChargingprofilePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/chargingprofile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ocpiChargingprofilePostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiChargingprofileSessionIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sessionId string
	activeChargingProfile *ActiveChargingProfile
}

func (r ApiOcpiChargingprofileSessionIdPutRequest) ActiveChargingProfile(activeChargingProfile ActiveChargingProfile) ApiOcpiChargingprofileSessionIdPutRequest {
	r.activeChargingProfile = &activeChargingProfile
	return r
}

func (r ApiOcpiChargingprofileSessionIdPutRequest) Execute() (*GenericResponse, *http.Response, error) {
	return r.ApiService.OcpiChargingprofileSessionIdPutExecute(r)
}

/*
OcpiChargingprofileSessionIdPut Update charging profile

Updates the Sender (typically SCSP) when the Receiver (typically CPO)  knows the ActiveChargingProfile has changed. The Receiver SHALL call this interface  every time it knows changes have been made that influence the ActiveChargingProfile  for an ongoing session AND the Sender has at least once successfully called the charging  profile Receiver PUT interface for this session (SetChargingProfile). If the Receiver  doesn't know the ActiveChargingProfile has changed (EVSE does not notify the Receiver  (typically CPO) of the change) it is not required to call this interface. The Receiver  SHALL NOT call this interface for any session where the Sender has never, successfully  called the charging profile Receiver PUT interface for this session (SetChargingProfile).  The Receiver SHALL send a useful relevant duration of ActiveChargingProfile to send to the  Sender. As a guide: between 5 and 60 minutes. If the Sender wants a longer ActiveChargingProfile  the Sender can always do a GET with a longer duration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The unique id that identifies the session in the CPO platform.
 @return ApiOcpiChargingprofileSessionIdPutRequest
*/
func (a *DefaultApiService) OcpiChargingprofileSessionIdPut(ctx context.Context, sessionId string) ApiOcpiChargingprofileSessionIdPutRequest {
	return ApiOcpiChargingprofileSessionIdPutRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return GenericResponse
func (a *DefaultApiService) OcpiChargingprofileSessionIdPutExecute(r ApiOcpiChargingprofileSessionIdPutRequest) (*GenericResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenericResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiChargingprofileSessionIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/chargingprofile/{session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.activeChargingProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiChargingprofilesSessionIdDurationUrlGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sessionId string
	duration int32
	url string
}

func (r ApiOcpiChargingprofilesSessionIdDurationUrlGetRequest) Execute() (*ChargingProfilesResponse, *http.Response, error) {
	return r.ApiService.OcpiChargingprofilesSessionIdDurationUrlGetExecute(r)
}

/*
OcpiChargingprofilesSessionIdDurationUrlGet Get active charging profile

Retrieves the ActiveChargingProfile as it is currently planned for the the given session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The unique id that identifies the session in the CPO platform.
 @param duration Length of the requested ActiveChargingProfile in seconds Duration in seconds.
 @param url URL that the ActiveChargingProfileResult POST should be send to. This URL  might contain an unique ID to be able to distinguish between GET ActiveChargingProfile  requests.
 @return ApiOcpiChargingprofilesSessionIdDurationUrlGetRequest
*/
func (a *DefaultApiService) OcpiChargingprofilesSessionIdDurationUrlGet(ctx context.Context, sessionId string, duration int32, url string) ApiOcpiChargingprofilesSessionIdDurationUrlGetRequest {
	return ApiOcpiChargingprofilesSessionIdDurationUrlGetRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		duration: duration,
		url: url,
	}
}

// Execute executes the request
//  @return ChargingProfilesResponse
func (a *DefaultApiService) OcpiChargingprofilesSessionIdDurationUrlGetExecute(r ApiOcpiChargingprofilesSessionIdDurationUrlGetRequest) (*ChargingProfilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChargingProfilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiChargingprofilesSessionIdDurationUrlGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/chargingprofiles/{session_id}/{duration}/{url}"
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"duration"+"}", url.PathEscape(parameterValueToString(r.duration, "duration")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"url"+"}", url.PathEscape(parameterValueToString(r.url, "url")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiChargingprofilesSessionIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sessionId string
	setChargingProfile *SetChargingProfile
}

func (r ApiOcpiChargingprofilesSessionIdPutRequest) SetChargingProfile(setChargingProfile SetChargingProfile) ApiOcpiChargingprofilesSessionIdPutRequest {
	r.setChargingProfile = &setChargingProfile
	return r
}

func (r ApiOcpiChargingprofilesSessionIdPutRequest) Execute() (*ChargingProfilesResponse, *http.Response, error) {
	return r.ApiService.OcpiChargingprofilesSessionIdPutExecute(r)
}

/*
OcpiChargingprofilesSessionIdPut Create or update charging profile on session

Creates a new ChargingProfile on a session, or replaces an existing ChargingProfile on the EVSE.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The unique id that identifies the session in the CPO platform.
 @return ApiOcpiChargingprofilesSessionIdPutRequest
*/
func (a *DefaultApiService) OcpiChargingprofilesSessionIdPut(ctx context.Context, sessionId string) ApiOcpiChargingprofilesSessionIdPutRequest {
	return ApiOcpiChargingprofilesSessionIdPutRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return ChargingProfilesResponse
func (a *DefaultApiService) OcpiChargingprofilesSessionIdPutExecute(r ApiOcpiChargingprofilesSessionIdPutRequest) (*ChargingProfilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChargingProfilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiChargingprofilesSessionIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/chargingprofiles/{session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setChargingProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiChargingprofilesSessionIdResponseUrlDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sessionId string
	responseUrl string
}

func (r ApiOcpiChargingprofilesSessionIdResponseUrlDeleteRequest) Execute() (*ChargingProfilesResponse, *http.Response, error) {
	return r.ApiService.OcpiChargingprofilesSessionIdResponseUrlDeleteExecute(r)
}

/*
OcpiChargingprofilesSessionIdResponseUrlDelete Delete charging profile on the session

Clears the ChargingProfile set by the eMSP on the given session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The unique id that identifies the session in the CPO platform.
 @param responseUrl URL that the ClearProfileResult POST should be send to. This URL  might contain an unique ID to be able to distinguish between DELETE  ChargingProfile requests.
 @return ApiOcpiChargingprofilesSessionIdResponseUrlDeleteRequest
*/
func (a *DefaultApiService) OcpiChargingprofilesSessionIdResponseUrlDelete(ctx context.Context, sessionId string, responseUrl string) ApiOcpiChargingprofilesSessionIdResponseUrlDeleteRequest {
	return ApiOcpiChargingprofilesSessionIdResponseUrlDeleteRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		responseUrl: responseUrl,
	}
}

// Execute executes the request
//  @return ChargingProfilesResponse
func (a *DefaultApiService) OcpiChargingprofilesSessionIdResponseUrlDeleteExecute(r ApiOcpiChargingprofilesSessionIdResponseUrlDeleteRequest) (*ChargingProfilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChargingProfilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiChargingprofilesSessionIdResponseUrlDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/chargingprofiles/{session_id}/{response_url}"
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"response_url"+"}", url.PathEscape(parameterValueToString(r.responseUrl, "responseUrl")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiClientinfoCountryCodePartyIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
}

func (r ApiOcpiClientinfoCountryCodePartyIdGetRequest) Execute() (*ClientsInfoResponse, *http.Response, error) {
	return r.ApiService.OcpiClientinfoCountryCodePartyIdGetExecute(r)
}

/*
OcpiClientinfoCountryCodePartyIdGet Get a ClientInfo object as it is stored in the connected clients system.

If the Hub wants to check the status of a ClientInfo  object in the connected clients system it might GET the object from the  connected clients system for validation purposes. The Hub is the owner  of the objects, so it would be illogical if the connected client system  had a different status or was missing an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the requested ClientInfo object.
 @param partyId Party ID (Provider ID) of the requested ClientInfo object.
 @return ApiOcpiClientinfoCountryCodePartyIdGetRequest
*/
func (a *DefaultApiService) OcpiClientinfoCountryCodePartyIdGet(ctx context.Context, countryCode string, partyId string) ApiOcpiClientinfoCountryCodePartyIdGetRequest {
	return ApiOcpiClientinfoCountryCodePartyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
	}
}

// Execute executes the request
//  @return ClientsInfoResponse
func (a *DefaultApiService) OcpiClientinfoCountryCodePartyIdGetExecute(r ApiOcpiClientinfoCountryCodePartyIdGetRequest) (*ClientsInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientsInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiClientinfoCountryCodePartyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/clientinfo/{country_code}/{party_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiClientinfoCountryCodePartyIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	clientInfo *ClientInfo
}

func (r ApiOcpiClientinfoCountryCodePartyIdPutRequest) ClientInfo(clientInfo ClientInfo) ApiOcpiClientinfoCountryCodePartyIdPutRequest {
	r.clientInfo = &clientInfo
	return r
}

func (r ApiOcpiClientinfoCountryCodePartyIdPutRequest) Execute() (*ClientsInfoResponse, *http.Response, error) {
	return r.ApiService.OcpiClientinfoCountryCodePartyIdPutExecute(r)
}

/*
OcpiClientinfoCountryCodePartyIdPut Create or update client info

New or updated ClientInfo objects are pushed from the Hub to a connected client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the eMSP sending this PUT request to the CPO system.
 @param partyId Party ID (Provider ID) of the eMSP sending this PUT request to the CPO system.
 @return ApiOcpiClientinfoCountryCodePartyIdPutRequest
*/
func (a *DefaultApiService) OcpiClientinfoCountryCodePartyIdPut(ctx context.Context, countryCode string, partyId string) ApiOcpiClientinfoCountryCodePartyIdPutRequest {
	return ApiOcpiClientinfoCountryCodePartyIdPutRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
	}
}

// Execute executes the request
//  @return ClientsInfoResponse
func (a *DefaultApiService) OcpiClientinfoCountryCodePartyIdPutExecute(r ApiOcpiClientinfoCountryCodePartyIdPutRequest) (*ClientsInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientsInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiClientinfoCountryCodePartyIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/clientinfo/{country_code}/{party_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiCommandsCommandPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	command string
	ocpiCommandsCommandPostRequest *OcpiCommandsCommandPostRequest
}

func (r ApiOcpiCommandsCommandPostRequest) OcpiCommandsCommandPostRequest(ocpiCommandsCommandPostRequest OcpiCommandsCommandPostRequest) ApiOcpiCommandsCommandPostRequest {
	r.ocpiCommandsCommandPostRequest = &ocpiCommandsCommandPostRequest
	return r
}

func (r ApiOcpiCommandsCommandPostRequest) Execute() (*CommandResponse, *http.Response, error) {
	return r.ApiService.OcpiCommandsCommandPostExecute(r)
}

/*
OcpiCommandsCommandPost Send a command

Send a command to the CPO, requesting the CPO to send  the command to the Charge Point

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param command Type of command that is requested.
 @return ApiOcpiCommandsCommandPostRequest
*/
func (a *DefaultApiService) OcpiCommandsCommandPost(ctx context.Context, command string) ApiOcpiCommandsCommandPostRequest {
	return ApiOcpiCommandsCommandPostRequest{
		ApiService: a,
		ctx: ctx,
		command: command,
	}
}

// Execute executes the request
//  @return CommandResponse
func (a *DefaultApiService) OcpiCommandsCommandPostExecute(r ApiOcpiCommandsCommandPostRequest) (*CommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiCommandsCommandPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/commands/{command}"
	localVarPath = strings.Replace(localVarPath, "{"+"command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ocpiCommandsCommandPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiCommandsCommandUidPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	command string
	uid string
	commandResult *CommandResult
}

// Result of the command request, from the Charge Point.
func (r ApiOcpiCommandsCommandUidPostRequest) CommandResult(commandResult CommandResult) ApiOcpiCommandsCommandUidPostRequest {
	r.commandResult = &commandResult
	return r
}

func (r ApiOcpiCommandsCommandUidPostRequest) Execute() (*CommandResponse, *http.Response, error) {
	return r.ApiService.OcpiCommandsCommandUidPostExecute(r)
}

/*
OcpiCommandsCommandUidPost Receive the asynchronous response from the Charge Point.

It is up to the implementation of the eMSP to determine  what parameters are put in the URL. The eMSP sends a URL in the POST  method body to the CPO. The CPO is required to use this URL for the  asynchronous response by the Charge Point. It is advised to make this  URL unique for every request to differentiate simultaneous commands,  for example by adding a unique id as a URL segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param command Type of command that is requested.
 @param uid
 @return ApiOcpiCommandsCommandUidPostRequest
*/
func (a *DefaultApiService) OcpiCommandsCommandUidPost(ctx context.Context, command string, uid string) ApiOcpiCommandsCommandUidPostRequest {
	return ApiOcpiCommandsCommandUidPostRequest{
		ApiService: a,
		ctx: ctx,
		command: command,
		uid: uid,
	}
}

// Execute executes the request
//  @return CommandResponse
func (a *DefaultApiService) OcpiCommandsCommandUidPostExecute(r ApiOcpiCommandsCommandUidPostRequest) (*CommandResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommandResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiCommandsCommandUidPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/commands/{command}/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.commandResult
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiHubclientinfoGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	dateFrom *string
	dateTo *string
	offset *int32
	limit *int32
}

// Return ClientInfo that have last_updated after or equal to Date/Time (inclusive).
func (r ApiOcpiHubclientinfoGetRequest) DateFrom(dateFrom string) ApiOcpiHubclientinfoGetRequest {
	r.dateFrom = &dateFrom
	return r
}

// Return ClientInfo that have last_updated up to Date/Time, but not including (exclusive).
func (r ApiOcpiHubclientinfoGetRequest) DateTo(dateTo string) ApiOcpiHubclientinfoGetRequest {
	r.dateTo = &dateTo
	return r
}

// The offset of the first object returned. Default is 0.
func (r ApiOcpiHubclientinfoGetRequest) Offset(offset int32) ApiOcpiHubclientinfoGetRequest {
	r.offset = &offset
	return r
}

// Maximum number of objects to GET.
func (r ApiOcpiHubclientinfoGetRequest) Limit(limit int32) ApiOcpiHubclientinfoGetRequest {
	r.limit = &limit
	return r
}

func (r ApiOcpiHubclientinfoGetRequest) Execute() (*ClientInfoResponse, *http.Response, error) {
	return r.ApiService.OcpiHubclientinfoGetExecute(r)
}

/*
OcpiHubclientinfoGet Get hub connected clients

Fetch information about clients connected to a Hub.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpiHubclientinfoGetRequest
*/
func (a *DefaultApiService) OcpiHubclientinfoGet(ctx context.Context) ApiOcpiHubclientinfoGetRequest {
	return ApiOcpiHubclientinfoGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClientInfoResponse
func (a *DefaultApiService) OcpiHubclientinfoGetExecute(r ApiOcpiHubclientinfoGetRequest) (*ClientInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiHubclientinfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/hubclientinfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	locationId string
	evseUid *string
	connectorId *string
}

// Evse.uid, required when requesting an EVSE or Connector object.
func (r ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest) EvseUid(evseUid string) ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest {
	r.evseUid = &evseUid
	return r
}

// Connector.id, required when requesting a Connector object.
func (r ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest) ConnectorId(connectorId string) ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest) Execute() (*OcpiLocationsLocationIdGet200Response, *http.Response, error) {
	return r.ApiService.OcpiLocationsCountryCodePartyIdLocationIdGetExecute(r)
}

/*
OcpiLocationsCountryCodePartyIdLocationIdGet Get location, EVSE or connector

If the CPO wants to check the status of a Location, EVSE  or Connector object in the eMSP system, it might GET the object from  the eMSP system for validation purposes. The CPO is the owner of the  objects, so it would be illogical if the eMSP system had a different  status or was missing an object. If a discrepancy is found, the CPO  might push an update to the eMSP via a PUT or PATCH call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the CPO requesting data from the eMSP system.
 @param partyId Party ID (Provider ID) of the CPO requesting data from the eMSP system.
 @param locationId Location.id of the Location object to retrieve.
 @return ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest
*/
func (a *DefaultApiService) OcpiLocationsCountryCodePartyIdLocationIdGet(ctx context.Context, countryCode string, partyId string, locationId string) ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest {
	return ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return OcpiLocationsLocationIdGet200Response
func (a *DefaultApiService) OcpiLocationsCountryCodePartyIdLocationIdGetExecute(r ApiOcpiLocationsCountryCodePartyIdLocationIdGetRequest) (*OcpiLocationsLocationIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OcpiLocationsLocationIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiLocationsCountryCodePartyIdLocationIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/locations/{country_code}/{party_id}/{location_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"location_id"+"}", url.PathEscape(parameterValueToString(r.locationId, "locationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.evseUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evse_uid", r.evseUid, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connector_id", r.connectorId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	locationId string
	evseUid *string
	connectorId *string
}

// Evse.uid, required when requesting an EVSE or Connector object.
func (r ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest) EvseUid(evseUid string) ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest {
	r.evseUid = &evseUid
	return r
}

// Connector.id, required when requesting a Connector object.
func (r ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest) ConnectorId(connectorId string) ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest) Execute() (*OcpiLocationsLocationIdGet200Response, *http.Response, error) {
	return r.ApiService.OcpiLocationsCountryCodePartyIdLocationIdPatchExecute(r)
}

/*
OcpiLocationsCountryCodePartyIdLocationIdPatch Sends new location object

Same as the PUT method, but only the fields/objects that have  to be updated have to be present. Other fields/objects that are not specified  as part of the request are considered unchanged. Therefore, this method is not  suitable to remove information shared earlier. Any request to the PATCH method  SHALL contain the last_updated field. When the PATCH is on a Connector Object,  the Receiver SHALL also set the new last_updated value on the parent EVSE and  Location Objects. When the PATCH is on a EVSE Object, the Receiver SHALL also  set the new last_updated value on the parent Location Object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the CPO requesting data from the eMSP system.
 @param partyId Party ID (Provider ID) of the CPO requesting data from the eMSP system.
 @param locationId Location.id of the Location object to retrieve.
 @return ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest
*/
func (a *DefaultApiService) OcpiLocationsCountryCodePartyIdLocationIdPatch(ctx context.Context, countryCode string, partyId string, locationId string) ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest {
	return ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return OcpiLocationsLocationIdGet200Response
func (a *DefaultApiService) OcpiLocationsCountryCodePartyIdLocationIdPatchExecute(r ApiOcpiLocationsCountryCodePartyIdLocationIdPatchRequest) (*OcpiLocationsLocationIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OcpiLocationsLocationIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiLocationsCountryCodePartyIdLocationIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/locations/{country_code}/{party_id}/{location_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"location_id"+"}", url.PathEscape(parameterValueToString(r.locationId, "locationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.evseUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evse_uid", r.evseUid, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connector_id", r.connectorId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	locationId string
	evseUid *string
	connectorId *string
	ocpiLocationsLocationIdGet200Response *OcpiLocationsLocationIdGet200Response
}

// Evse.uid, required when requesting an EVSE or Connector object.
func (r ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest) EvseUid(evseUid string) ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest {
	r.evseUid = &evseUid
	return r
}

// Connector.id, required when requesting a Connector object.
func (r ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest) ConnectorId(connectorId string) ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest) OcpiLocationsLocationIdGet200Response(ocpiLocationsLocationIdGet200Response OcpiLocationsLocationIdGet200Response) ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest {
	r.ocpiLocationsLocationIdGet200Response = &ocpiLocationsLocationIdGet200Response
	return r
}

func (r ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest) Execute() (*OcpiLocationsLocationIdGet200Response, *http.Response, error) {
	return r.ApiService.OcpiLocationsCountryCodePartyIdLocationIdPutExecute(r)
}

/*
OcpiLocationsCountryCodePartyIdLocationIdPut Sends new location object

The CPO pushes available Location, EVSE or Connector  objects to the eMSP. PUT can be used to send new Location objects to  the eMSP but also to replace existing Locations. When the PUT only  contains a Connector Object, the Receiver SHALL also set the new  last_updated value on the parent EVSE and Location Objects. When  the PUT only contains a EVSE Object, the Receiver SHALL also set 	he new last_updated value on the parent Location Object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the CPO requesting data from the eMSP system.
 @param partyId Party ID (Provider ID) of the CPO requesting data from the eMSP system.
 @param locationId Location.id of the Location object to retrieve.
 @return ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest
*/
func (a *DefaultApiService) OcpiLocationsCountryCodePartyIdLocationIdPut(ctx context.Context, countryCode string, partyId string, locationId string) ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest {
	return ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return OcpiLocationsLocationIdGet200Response
func (a *DefaultApiService) OcpiLocationsCountryCodePartyIdLocationIdPutExecute(r ApiOcpiLocationsCountryCodePartyIdLocationIdPutRequest) (*OcpiLocationsLocationIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OcpiLocationsLocationIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiLocationsCountryCodePartyIdLocationIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/locations/{country_code}/{party_id}/{location_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"location_id"+"}", url.PathEscape(parameterValueToString(r.locationId, "locationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.evseUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evse_uid", r.evseUid, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connector_id", r.connectorId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ocpiLocationsLocationIdGet200Response
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiLocationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	dateFrom *string
	dateTo *string
	offset *int32
	limit *int32
}

// Return Locations that have last_updated after or equal to this date time (inclusive).
func (r ApiOcpiLocationsGetRequest) DateFrom(dateFrom string) ApiOcpiLocationsGetRequest {
	r.dateFrom = &dateFrom
	return r
}

// Return Locations that have last_updated up to this date time, but not including (exclusive).
func (r ApiOcpiLocationsGetRequest) DateTo(dateTo string) ApiOcpiLocationsGetRequest {
	r.dateTo = &dateTo
	return r
}

// The offset of the first object returned. Default is 0.
func (r ApiOcpiLocationsGetRequest) Offset(offset int32) ApiOcpiLocationsGetRequest {
	r.offset = &offset
	return r
}

// Maximum number of objects to GET.
func (r ApiOcpiLocationsGetRequest) Limit(limit int32) ApiOcpiLocationsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiOcpiLocationsGetRequest) Execute() (*Locations, *http.Response, error) {
	return r.ApiService.OcpiLocationsGetExecute(r)
}

/*
OcpiLocationsGet Get available locations

Depending on the URL Segments provided, the GET  request can either be used to retrieve information about a  list of available Locations (with EVSEs and Connectors) at  a CPO (GET List) or it can be used to retrieve information  about one specific Location, OCPI 2.2.1 51 EVSE or Connector  (GET Object).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpiLocationsGetRequest
*/
func (a *DefaultApiService) OcpiLocationsGet(ctx context.Context) ApiOcpiLocationsGetRequest {
	return ApiOcpiLocationsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Locations
func (a *DefaultApiService) OcpiLocationsGetExecute(r ApiOcpiLocationsGetRequest) (*Locations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Locations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiLocationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/locations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiLocationsLocationIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	locationId string
	evseUid *string
	connectorId *string
}

// Evse.uid, required when requesting an EVSE or Connector object.
func (r ApiOcpiLocationsLocationIdGetRequest) EvseUid(evseUid string) ApiOcpiLocationsLocationIdGetRequest {
	r.evseUid = &evseUid
	return r
}

// Connector.id, required when requesting a Connector object.
func (r ApiOcpiLocationsLocationIdGetRequest) ConnectorId(connectorId string) ApiOcpiLocationsLocationIdGetRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiOcpiLocationsLocationIdGetRequest) Execute() (*OcpiLocationsLocationIdGet200Response, *http.Response, error) {
	return r.ApiService.OcpiLocationsLocationIdGetExecute(r)
}

/*
OcpiLocationsLocationIdGet Get location, EVSE or connector

Endpoint structure definition for retrieving a Location, EVSE or Connector:

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locationId Location.id of the Location object to retrieve.
 @return ApiOcpiLocationsLocationIdGetRequest
*/
func (a *DefaultApiService) OcpiLocationsLocationIdGet(ctx context.Context, locationId string) ApiOcpiLocationsLocationIdGetRequest {
	return ApiOcpiLocationsLocationIdGetRequest{
		ApiService: a,
		ctx: ctx,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return OcpiLocationsLocationIdGet200Response
func (a *DefaultApiService) OcpiLocationsLocationIdGetExecute(r ApiOcpiLocationsLocationIdGetRequest) (*OcpiLocationsLocationIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OcpiLocationsLocationIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiLocationsLocationIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/locations/{location_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"location_id"+"}", url.PathEscape(parameterValueToString(r.locationId, "locationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.evseUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evse_uid", r.evseUid, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connector_id", r.connectorId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiSessionsCountryCodePartyIdSessionIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	sessionId string
}

func (r ApiOcpiSessionsCountryCodePartyIdSessionIdGetRequest) Execute() (*SessionResponse, *http.Response, error) {
	return r.ApiService.OcpiSessionsCountryCodePartyIdSessionIdGetExecute(r)
}

/*
OcpiSessionsCountryCodePartyIdSessionIdGet Get session with session_id

The CPO system might request the current version of  a Session object from the eMSP's system to, for example, validate the state, or because the CPO has received an error during a PATCH operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the CPO performing the GET on the eMSP's system
 @param partyId Party ID (Provider ID) of the CPO performing the GET on the eMSP's system.
 @param sessionId Id of the Session object to get from the eMSP's system.
 @return ApiOcpiSessionsCountryCodePartyIdSessionIdGetRequest
*/
func (a *DefaultApiService) OcpiSessionsCountryCodePartyIdSessionIdGet(ctx context.Context, countryCode string, partyId string, sessionId string) ApiOcpiSessionsCountryCodePartyIdSessionIdGetRequest {
	return ApiOcpiSessionsCountryCodePartyIdSessionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return SessionResponse
func (a *DefaultApiService) OcpiSessionsCountryCodePartyIdSessionIdGetExecute(r ApiOcpiSessionsCountryCodePartyIdSessionIdGetRequest) (*SessionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiSessionsCountryCodePartyIdSessionIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/sessions/{country_code}/{party_id}/{session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiSessionsCountryCodePartyIdSessionIdPatchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	sessionId string
}

func (r ApiOcpiSessionsCountryCodePartyIdSessionIdPatchRequest) Execute() (*SessionResponse, *http.Response, error) {
	return r.ApiService.OcpiSessionsCountryCodePartyIdSessionIdPatchExecute(r)
}

/*
OcpiSessionsCountryCodePartyIdSessionIdPatch Update session with session_id

Same as the PUT method, but only the fields/objects that need to  be updated have to be present. Fields/objects which are not specified are  considered unchanged. Any request to the PATCH method SHALL contain the last_updated  field. The PATCH method of the Session Receiver interface works on the entire Session  object only. It is not allowed to use extra URL segments to try to PATCH fields of inner  objects of the Session object directly. When a PATCH request contains the charging_periods  field (inside a Session object), this SHALL be processed as a request to add all the  ChargingPeriod objects to the existing Session object. If the request charging_periods  list is omitted (or contains an empty list), no changes SHALL be made to the existing  list of charging_periods. If existing ChargingPeriod objects in a Session need to be    replaced or removed, the Sender SHALL use the PUT method to replace the entire Session  object (including all the charging_periods).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the CPO performing this PATCH on the eMSP's system.  This SHALL be the same value as the country_code in the Session object being pushed.
 @param partyId Party ID (Provider ID) of the CPO performing this PATCH on the eMSP's  system. This SHALL be the same value as the party_id in the Session object being  pushed.
 @param sessionId Id of the new or updated Session object.
 @return ApiOcpiSessionsCountryCodePartyIdSessionIdPatchRequest
*/
func (a *DefaultApiService) OcpiSessionsCountryCodePartyIdSessionIdPatch(ctx context.Context, countryCode string, partyId string, sessionId string) ApiOcpiSessionsCountryCodePartyIdSessionIdPatchRequest {
	return ApiOcpiSessionsCountryCodePartyIdSessionIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return SessionResponse
func (a *DefaultApiService) OcpiSessionsCountryCodePartyIdSessionIdPatchExecute(r ApiOcpiSessionsCountryCodePartyIdSessionIdPatchRequest) (*SessionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiSessionsCountryCodePartyIdSessionIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/sessions/{country_code}/{party_id}/{session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiSessionsCountryCodePartyIdSessionIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	sessionId string
	session *Session
}

func (r ApiOcpiSessionsCountryCodePartyIdSessionIdPutRequest) Session(session Session) ApiOcpiSessionsCountryCodePartyIdSessionIdPutRequest {
	r.session = &session
	return r
}

func (r ApiOcpiSessionsCountryCodePartyIdSessionIdPutRequest) Execute() (*SessionResponse, *http.Response, error) {
	return r.ApiService.OcpiSessionsCountryCodePartyIdSessionIdPutExecute(r)
}

/*
OcpiSessionsCountryCodePartyIdSessionIdPut Update session with session_id



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the CPO performing this PUT on the eMSP's system.  This SHALL be the same value as the country_code in the Session object being pushed.
 @param partyId Party ID (Provider ID) of the CPO performing this PUT on the eMSP's  system. This SHALL be the same value as the party_id in the Session object being  pushed.
 @param sessionId Id of the new or updated Session object.
 @return ApiOcpiSessionsCountryCodePartyIdSessionIdPutRequest
*/
func (a *DefaultApiService) OcpiSessionsCountryCodePartyIdSessionIdPut(ctx context.Context, countryCode string, partyId string, sessionId string) ApiOcpiSessionsCountryCodePartyIdSessionIdPutRequest {
	return ApiOcpiSessionsCountryCodePartyIdSessionIdPutRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return SessionResponse
func (a *DefaultApiService) OcpiSessionsCountryCodePartyIdSessionIdPutExecute(r ApiOcpiSessionsCountryCodePartyIdSessionIdPutRequest) (*SessionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiSessionsCountryCodePartyIdSessionIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/sessions/{country_code}/{party_id}/{session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.session
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiSessionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	dateFrom *string
	dateTo *string
	offset *int32
	limit *int32
}

// Return Sessions that have last_updated after or equal to this date time (inclusive).
func (r ApiOcpiSessionsGetRequest) DateFrom(dateFrom string) ApiOcpiSessionsGetRequest {
	r.dateFrom = &dateFrom
	return r
}

// Return Sessions that have last_updated up to this date time, but not including (exclusive).
func (r ApiOcpiSessionsGetRequest) DateTo(dateTo string) ApiOcpiSessionsGetRequest {
	r.dateTo = &dateTo
	return r
}

// The offset of the first object returned. Default is 0.
func (r ApiOcpiSessionsGetRequest) Offset(offset int32) ApiOcpiSessionsGetRequest {
	r.offset = &offset
	return r
}

// Maximum number of objects to GET.
func (r ApiOcpiSessionsGetRequest) Limit(limit int32) ApiOcpiSessionsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiOcpiSessionsGetRequest) Execute() (*SessionsResponse, *http.Response, error) {
	return r.ApiService.OcpiSessionsGetExecute(r)
}

/*
OcpiSessionsGet Get charging sessions

Fetch Session objects of charging sessions last  updated between the {date_from} and {date_to} (paginated).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpiSessionsGetRequest
*/
func (a *DefaultApiService) OcpiSessionsGet(ctx context.Context) ApiOcpiSessionsGetRequest {
	return ApiOcpiSessionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SessionsResponse
func (a *DefaultApiService) OcpiSessionsGetExecute(r ApiOcpiSessionsGetRequest) (*SessionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiSessionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiSessionsSessionIdChargingPreferencesPutRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sessionId string
	chargingPreferences *ChargingPreferences
}

func (r ApiOcpiSessionsSessionIdChargingPreferencesPutRequest) ChargingPreferences(chargingPreferences ChargingPreferences) ApiOcpiSessionsSessionIdChargingPreferencesPutRequest {
	r.chargingPreferences = &chargingPreferences
	return r
}

func (r ApiOcpiSessionsSessionIdChargingPreferencesPutRequest) Execute() (*ChargingPreferencesResponse, *http.Response, error) {
	return r.ApiService.OcpiSessionsSessionIdChargingPreferencesPutExecute(r)
}

/*
OcpiSessionsSessionIdChargingPreferencesPut Update charging session

Setting Charging Preferences of an ongoing session. If a PUT with ChargingPreferences is received for an EVSE that  does not have the capability CHARGING_PREFERENCES_CAPABLE, the  receiver should respond with an HTTP status of 404 and an OCPI  status code of 2001 in the OCPI response object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Session.id of the Session for which the Charging Preferences are to be set.
 @return ApiOcpiSessionsSessionIdChargingPreferencesPutRequest
*/
func (a *DefaultApiService) OcpiSessionsSessionIdChargingPreferencesPut(ctx context.Context, sessionId string) ApiOcpiSessionsSessionIdChargingPreferencesPutRequest {
	return ApiOcpiSessionsSessionIdChargingPreferencesPutRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return ChargingPreferencesResponse
func (a *DefaultApiService) OcpiSessionsSessionIdChargingPreferencesPutExecute(r ApiOcpiSessionsSessionIdChargingPreferencesPutRequest) (*ChargingPreferencesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChargingPreferencesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiSessionsSessionIdChargingPreferencesPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/sessions/{session_id}/charging_preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"session_id"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chargingPreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiTariffsCountryCodePartyIdTariffIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	tariffId string
}

func (r ApiOcpiTariffsCountryCodePartyIdTariffIdDeleteRequest) Execute() (*TariffDeleteResponse, *http.Response, error) {
	return r.ApiService.OcpiTariffsCountryCodePartyIdTariffIdDeleteExecute(r)
}

/*
OcpiTariffsCountryCodePartyIdTariffIdDelete Delete tariff

Delete a Tariff object which is not used any more and will not be used in the future.  Before deleting a Tariff object, it is RECOMMENDED to ensure that the Tariff object is not referenced  by any Connector object within the tariff_ids.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the CPO performing the PUT request on the eMSP's system.
 @param partyId Party ID (Provider ID) of the CPO performing the PUT request on the eMSP's system.
 @param tariffId Tariff.id of the Tariff object to delete.
 @return ApiOcpiTariffsCountryCodePartyIdTariffIdDeleteRequest
*/
func (a *DefaultApiService) OcpiTariffsCountryCodePartyIdTariffIdDelete(ctx context.Context, countryCode string, partyId string, tariffId string) ApiOcpiTariffsCountryCodePartyIdTariffIdDeleteRequest {
	return ApiOcpiTariffsCountryCodePartyIdTariffIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		tariffId: tariffId,
	}
}

// Execute executes the request
//  @return TariffDeleteResponse
func (a *DefaultApiService) OcpiTariffsCountryCodePartyIdTariffIdDeleteExecute(r ApiOcpiTariffsCountryCodePartyIdTariffIdDeleteRequest) (*TariffDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TariffDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiTariffsCountryCodePartyIdTariffIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/tariffs/{country_code}/{party_id}/{tariff_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tariff_id"+"}", url.PathEscape(parameterValueToString(r.tariffId, "tariffId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiTariffsCountryCodePartyIdTariffIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	tariffId string
}

func (r ApiOcpiTariffsCountryCodePartyIdTariffIdGetRequest) Execute() (*TariffResponse, *http.Response, error) {
	return r.ApiService.OcpiTariffsCountryCodePartyIdTariffIdGetExecute(r)
}

/*
OcpiTariffsCountryCodePartyIdTariffIdGet Get tariff with tariff_id

If the CPO wants to check the status of a Tariff in the  eMSP's system, it might GET the object from the eMSP's system for  validation purposes. After all, the CPO is the owner of the object,  so it would be illogical if the eMSP's system had a different status  or was missing the object entirely

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the CPO performing the GET on the eMSP's system
 @param partyId Party ID (Provider ID) of the CPO performing the GET on the eMSP's system.
 @param tariffId Tariff.id of the Tariff object to retrieve.
 @return ApiOcpiTariffsCountryCodePartyIdTariffIdGetRequest
*/
func (a *DefaultApiService) OcpiTariffsCountryCodePartyIdTariffIdGet(ctx context.Context, countryCode string, partyId string, tariffId string) ApiOcpiTariffsCountryCodePartyIdTariffIdGetRequest {
	return ApiOcpiTariffsCountryCodePartyIdTariffIdGetRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		tariffId: tariffId,
	}
}

// Execute executes the request
//  @return TariffResponse
func (a *DefaultApiService) OcpiTariffsCountryCodePartyIdTariffIdGetExecute(r ApiOcpiTariffsCountryCodePartyIdTariffIdGetRequest) (*TariffResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TariffResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiTariffsCountryCodePartyIdTariffIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/tariffs/{country_code}/{party_id}/{tariff_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tariff_id"+"}", url.PathEscape(parameterValueToString(r.tariffId, "tariffId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiTariffsCountryCodePartyIdTariffIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	tariffId string
	tariff *Tariff
}

func (r ApiOcpiTariffsCountryCodePartyIdTariffIdPutRequest) Tariff(tariff Tariff) ApiOcpiTariffsCountryCodePartyIdTariffIdPutRequest {
	r.tariff = &tariff
	return r
}

func (r ApiOcpiTariffsCountryCodePartyIdTariffIdPutRequest) Execute() (*TariffResponse, *http.Response, error) {
	return r.ApiService.OcpiTariffsCountryCodePartyIdTariffIdPutExecute(r)
}

/*
OcpiTariffsCountryCodePartyIdTariffIdPut Update tariff

New or updated Tariff objects are pushed from the CPO to the eMSP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the CPO performing the PUT request on the eMSP's system.  This SHALL be the same value as the country_code in the Tariff object being pushed.
 @param partyId Party ID (Provider ID) of the CPO performing the PUT request on the eMSP's system. This SHALL be the same value as the party_id in the Tariff object being pushed.
 @param tariffId Tariff.id of the Tariff object to create or replace.
 @return ApiOcpiTariffsCountryCodePartyIdTariffIdPutRequest
*/
func (a *DefaultApiService) OcpiTariffsCountryCodePartyIdTariffIdPut(ctx context.Context, countryCode string, partyId string, tariffId string) ApiOcpiTariffsCountryCodePartyIdTariffIdPutRequest {
	return ApiOcpiTariffsCountryCodePartyIdTariffIdPutRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		tariffId: tariffId,
	}
}

// Execute executes the request
//  @return TariffResponse
func (a *DefaultApiService) OcpiTariffsCountryCodePartyIdTariffIdPutExecute(r ApiOcpiTariffsCountryCodePartyIdTariffIdPutRequest) (*TariffResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TariffResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiTariffsCountryCodePartyIdTariffIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/tariffs/{country_code}/{party_id}/{tariff_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tariff_id"+"}", url.PathEscape(parameterValueToString(r.tariffId, "tariffId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tariff
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiTariffsGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	dateFrom *string
	dateTo *string
	offset *int32
	limit *int32
}

// Return Tariffs that have last_updated after or equal to Date/Time (inclusive).
func (r ApiOcpiTariffsGetRequest) DateFrom(dateFrom string) ApiOcpiTariffsGetRequest {
	r.dateFrom = &dateFrom
	return r
}

// Return Tariffs that have last_updated up to Date/Time, but not including (exclusive).
func (r ApiOcpiTariffsGetRequest) DateTo(dateTo string) ApiOcpiTariffsGetRequest {
	r.dateTo = &dateTo
	return r
}

// The offset of the first object returned. Default is 0.
func (r ApiOcpiTariffsGetRequest) Offset(offset int32) ApiOcpiTariffsGetRequest {
	r.offset = &offset
	return r
}

// Maximum number of objects to GET.
func (r ApiOcpiTariffsGetRequest) Limit(limit int32) ApiOcpiTariffsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiOcpiTariffsGetRequest) Execute() (*TariffsResponse, *http.Response, error) {
	return r.ApiService.OcpiTariffsGetExecute(r)
}

/*
OcpiTariffsGet Get tariffs

Fetch tariffs from the CPO's system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpiTariffsGetRequest
*/
func (a *DefaultApiService) OcpiTariffsGet(ctx context.Context) ApiOcpiTariffsGetRequest {
	return ApiOcpiTariffsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TariffsResponse
func (a *DefaultApiService) OcpiTariffsGetExecute(r ApiOcpiTariffsGetRequest) (*TariffsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TariffsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiTariffsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/tariffs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiTokenUidAuthorizePostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	tokenUid string
	type_ *string
	locationReferences *LocationReferences
}

// Token.type of the Token to retrieve. Default if omitted: RFID
func (r ApiOcpiTokenUidAuthorizePostRequest) Type_(type_ string) ApiOcpiTokenUidAuthorizePostRequest {
	r.type_ = &type_
	return r
}

func (r ApiOcpiTokenUidAuthorizePostRequest) LocationReferences(locationReferences LocationReferences) ApiOcpiTokenUidAuthorizePostRequest {
	r.locationReferences = &locationReferences
	return r
}

func (r ApiOcpiTokenUidAuthorizePostRequest) Execute() (*Authorization, *http.Response, error) {
	return r.ApiService.OcpiTokenUidAuthorizePostExecute(r)
}

/*
OcpiTokenUidAuthorizePost Authorization

Do a 'real-time' authorization request to the eMSP system,  validating if a Token might be used (at the optionally given Location).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tokenUid Token.uid of the Token for which authorization is requested.
 @return ApiOcpiTokenUidAuthorizePostRequest
*/
func (a *DefaultApiService) OcpiTokenUidAuthorizePost(ctx context.Context, tokenUid string) ApiOcpiTokenUidAuthorizePostRequest {
	return ApiOcpiTokenUidAuthorizePostRequest{
		ApiService: a,
		ctx: ctx,
		tokenUid: tokenUid,
	}
}

// Execute executes the request
//  @return Authorization
func (a *DefaultApiService) OcpiTokenUidAuthorizePostExecute(r ApiOcpiTokenUidAuthorizePostRequest) (*Authorization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Authorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiTokenUidAuthorizePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/{token_uid}/authorize"
	localVarPath = strings.Replace(localVarPath, "{"+"token_uid"+"}", url.PathEscape(parameterValueToString(r.tokenUid, "tokenUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.locationReferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiTokensCountryCodePartyIdTokenUidGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	tokenUid string
	type_ *string
}

// Token.type of the Token to retrieve. Default if omitted: RFID
func (r ApiOcpiTokensCountryCodePartyIdTokenUidGetRequest) Type_(type_ string) ApiOcpiTokensCountryCodePartyIdTokenUidGetRequest {
	r.type_ = &type_
	return r
}

func (r ApiOcpiTokensCountryCodePartyIdTokenUidGetRequest) Execute() (*TokenResponse, *http.Response, error) {
	return r.ApiService.OcpiTokensCountryCodePartyIdTokenUidGetExecute(r)
}

/*
OcpiTokensCountryCodePartyIdTokenUidGet Get the token object

If the eMSP wants to check the status of a Token in the  CPO system it might GET the object from the CPO system for validation  purposes. The eMSP is the owner of the objects, so it would be illogical  if the CPO system had a different status or was missing an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the eMSP requesting this GET from the CPO system.
 @param partyId Party ID (Provider ID) of the eMSP requesting this GET from the CPO system.
 @param tokenUid Token.uid of the Token object to retrieve.
 @return ApiOcpiTokensCountryCodePartyIdTokenUidGetRequest
*/
func (a *DefaultApiService) OcpiTokensCountryCodePartyIdTokenUidGet(ctx context.Context, countryCode string, partyId string, tokenUid string) ApiOcpiTokensCountryCodePartyIdTokenUidGetRequest {
	return ApiOcpiTokensCountryCodePartyIdTokenUidGetRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		tokenUid: tokenUid,
	}
}

// Execute executes the request
//  @return TokenResponse
func (a *DefaultApiService) OcpiTokensCountryCodePartyIdTokenUidGetExecute(r ApiOcpiTokensCountryCodePartyIdTokenUidGetRequest) (*TokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiTokensCountryCodePartyIdTokenUidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/tokens/{country_code}/{party_id}/{token_uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token_uid"+"}", url.PathEscape(parameterValueToString(r.tokenUid, "tokenUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiTokensCountryCodePartyIdTokenUidPatchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	tokenUid string
	type_ *string
}

// Token.type of the Token to retrieve. Default if omitted: RFID
func (r ApiOcpiTokensCountryCodePartyIdTokenUidPatchRequest) Type_(type_ string) ApiOcpiTokensCountryCodePartyIdTokenUidPatchRequest {
	r.type_ = &type_
	return r
}

func (r ApiOcpiTokensCountryCodePartyIdTokenUidPatchRequest) Execute() (*TokenResponse, *http.Response, error) {
	return r.ApiService.OcpiTokensCountryCodePartyIdTokenUidPatchExecute(r)
}

/*
OcpiTokensCountryCodePartyIdTokenUidPatch Update token object

Same as the PUT method, but only the fields/objects  that have to be updated have to be present, other fields/objects  that are not specified are considered unchanged. Any request to the  PATCH method SHALL contain the last_updated field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the eMSP sending this PATCH request to the CPO system.  This SHALL be the same value as the country_code in the Token object being pushed.
 @param partyId Party ID (Provider ID) of the eMSP sending this PATCH request to the CPO  system. This SHALL be the same value as the party_id in the Token object being pushed.
 @param tokenUid Token.uid of the Token object to retrieve.
 @return ApiOcpiTokensCountryCodePartyIdTokenUidPatchRequest
*/
func (a *DefaultApiService) OcpiTokensCountryCodePartyIdTokenUidPatch(ctx context.Context, countryCode string, partyId string, tokenUid string) ApiOcpiTokensCountryCodePartyIdTokenUidPatchRequest {
	return ApiOcpiTokensCountryCodePartyIdTokenUidPatchRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		tokenUid: tokenUid,
	}
}

// Execute executes the request
//  @return TokenResponse
func (a *DefaultApiService) OcpiTokensCountryCodePartyIdTokenUidPatchExecute(r ApiOcpiTokensCountryCodePartyIdTokenUidPatchRequest) (*TokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiTokensCountryCodePartyIdTokenUidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/tokens/{country_code}/{party_id}/{token_uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token_uid"+"}", url.PathEscape(parameterValueToString(r.tokenUid, "tokenUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	countryCode string
	partyId string
	tokenUid string
	type_ *string
	token *Token
}

// Token.type of the Token to retrieve. Default if omitted: RFID
func (r ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest) Type_(type_ string) ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest {
	r.type_ = &type_
	return r
}

func (r ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest) Token(token Token) ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest {
	r.token = &token
	return r
}

func (r ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest) Execute() (*TokenResponse, *http.Response, error) {
	return r.ApiService.OcpiTokensCountryCodePartyIdTokenUidPutExecute(r)
}

/*
OcpiTokensCountryCodePartyIdTokenUidPut Update token object

New or updated Token objects are pushed from the eMSP to the CPO.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryCode Country code of the eMSP sending this PUT request to the CPO system.  This SHALL be the same value as the country_code in the Token object being pushed.
 @param partyId Party ID (Provider ID) of the eMSP sending this PUT request to the CPO  system. This SHALL be the same value as the party_id in the Token object being pushed.
 @param tokenUid Token.uid of the Token object to retrieve.
 @return ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest
*/
func (a *DefaultApiService) OcpiTokensCountryCodePartyIdTokenUidPut(ctx context.Context, countryCode string, partyId string, tokenUid string) ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest {
	return ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest{
		ApiService: a,
		ctx: ctx,
		countryCode: countryCode,
		partyId: partyId,
		tokenUid: tokenUid,
	}
}

// Execute executes the request
//  @return TokenResponse
func (a *DefaultApiService) OcpiTokensCountryCodePartyIdTokenUidPutExecute(r ApiOcpiTokensCountryCodePartyIdTokenUidPutRequest) (*TokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiTokensCountryCodePartyIdTokenUidPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/tokens/{country_code}/{party_id}/{token_uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"country_code"+"}", url.PathEscape(parameterValueToString(r.countryCode, "countryCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"party_id"+"}", url.PathEscape(parameterValueToString(r.partyId, "partyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token_uid"+"}", url.PathEscape(parameterValueToString(r.tokenUid, "tokenUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.token
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiTokensGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	dateFrom *string
	dateTo *string
	offset *int32
	limit *int32
}

// Return tokens that have last_updated after or equal to this Date/Time (inclusive).
func (r ApiOcpiTokensGetRequest) DateFrom(dateFrom string) ApiOcpiTokensGetRequest {
	r.dateFrom = &dateFrom
	return r
}

// Return tokens that have last_updated up to Date/Time, but not including (exclusive).
func (r ApiOcpiTokensGetRequest) DateTo(dateTo string) ApiOcpiTokensGetRequest {
	r.dateTo = &dateTo
	return r
}

// The offset of the first object returned. Default is 0.
func (r ApiOcpiTokensGetRequest) Offset(offset int32) ApiOcpiTokensGetRequest {
	r.offset = &offset
	return r
}

// Maximum number of objects to GET.
func (r ApiOcpiTokensGetRequest) Limit(limit int32) ApiOcpiTokensGetRequest {
	r.limit = &limit
	return r
}

func (r ApiOcpiTokensGetRequest) Execute() (*TokensResponse, *http.Response, error) {
	return r.ApiService.OcpiTokensGetExecute(r)
}

/*
OcpiTokensGet Get tokens

Fetch information about Tokens known in the eMSP systems.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpiTokensGetRequest
*/
func (a *DefaultApiService) OcpiTokensGet(ctx context.Context) ApiOcpiTokensGetRequest {
	return ApiOcpiTokensGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokensResponse
func (a *DefaultApiService) OcpiTokensGetExecute(r ApiOcpiTokensGetRequest) (*TokensResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokensResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiTokensGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOcpiVersionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r ApiOcpiVersionsGetRequest) Execute() (*Versions, *http.Response, error) {
	return r.ApiService.OcpiVersionsGetExecute(r)
}

/*
OcpiVersionsGet Get supported versions

Fetch information about the supported versions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOcpiVersionsGetRequest
*/
func (a *DefaultApiService) OcpiVersionsGet(ctx context.Context) ApiOcpiVersionsGetRequest {
	return ApiOcpiVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Versions
func (a *DefaultApiService) OcpiVersionsGetExecute(r ApiOcpiVersionsGetRequest) (*Versions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Versions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.OcpiVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ocpi/versions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
